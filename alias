# ==========================================================
# üöÄ PROFESSIONAL GIT PRODUCTIVITY ALIASES & FUNCTIONS
# Optimized for Rebase, Squash, and Clean History Workflow
# ==========================================================

# ----------------------------------------------------------
# I. BASIC & NAVIGATION ALIASES (Daily Use)
# ----------------------------------------------------------
alias g='git checkout main'     # Go to Main: Quickly switches to the main branch.
alias ga='git add'              # Adds specific files to staging.
alias gaa='git add --all'       # Stages all changes (modified, deleted, new files).
alias gst='git status -sb'      # Quick Status: Shows a short, summarized status of your branch.
alias gc='git commit'           # Creates a new commit.
alias gt='git stash'            # Stash: Temporarily shelves current changes.
alias co='git checkout'         # Switches to an existing branch.
alias cob='git checkout -b'     # New Branch: Creates and switches to a new branch.
alias br='git branch'           # Lists local branches.
alias pu='git push'             # Pushes committed changes to the remote.
alias pl='git pull'             # Fetches and integrates changes from the remote.


# ----------------------------------------------------------
# II. ADVANCED HISTORY & SAFETY ALIASES
# ----------------------------------------------------------
alias gl='git log --oneline --graph --decorate'              # Graphical Log: Shows the history with a clean graph view.
alias glb='git log --oneline --graph --decorate main..HEAD'  # Branch Log: Shows only the commits unique to the current branch.
alias gf='git fetch --all --prune'                           # Fetch & Prune: Updates remotes and cleans up deleted remote branches.
alias grf='git reflog'                                       # Reflog: Shows a log of where HEAD has been (critical for recovery).
alias fpush='git push --force-with-lease'                    # Safe Force Push: Pushes after rebase/squash only if the remote hasn't changed.
alias grs='git reset --soft HEAD~1'                          # Soft Reset: Undoes the last commit, preserving changes in the staging area.
alias gra='git rebase --abort'                               # Rebase Abort: Stops a rebase in progress.
alias grc='git rebase --continue'                            # Rebase Continue: Continues a rebase after conflicts are resolved.


# ----------------------------------------------------------
# III. AUTOMATION FUNCTIONS
# ----------------------------------------------------------

# FUNCTION: s() (Commit WIP)
# Stages all changes (git add .) and creates a temporary commit with the message "WIP".
function s() {
    echo "Staging all files (git add .)..."
    git add .
    
    echo "Creating commit: WIP"
    git commit -m "WIP"
    
    # Check if the commit was successful
    if [ $? -eq 0 ]; then
        echo "‚úÖ WIP commit created successfully."
    else
        echo "‚ùå Error: Commit failed (files already staged or working directory clean)."
    fi
}

# FUNCTION: gnb() (Git New Branch)
# Creates a local branch and pushes it to the remote, establishing upstream tracking.
# Usage: gnb <branch-name>
function gnb() {
    # Check for required argument
    if [ -z "$1" ]; then
        echo "Error: Please provide a name for the new branch."
        return 1
    fi
    
    # 1. Create the local branch and switch to it
    git checkout -b "$1"
    
    # 2. Push the branch and set the upstream tracking
    if [ $? -eq 0 ]; then
        echo "Pushing branch and setting upstream tracking..."
        git push --set-upstream origin "$1"
    fi
}

# FUNCTION: gsq() (Git Squash All)
# Resets the branch history to origin/main (or base), leaving all changes staged for a clean, unified commit.
function gsq() {
    # Define the base branch for comparison
    local base_branch="origin/main"
    
    # 1. Find the commit where the current branch diverged from the base
    local merge_base
    merge_base=$(git merge-base "$base_branch" HEAD)
    
    if [ -z "$merge_base" ]; then
        echo "Error: Could not find the common merge base with $base_branch."
        return 1
    fi  
    
    echo "WARNING: Undoing all commits up to the base commit: $merge_base, changes will be staged."
    
    # 2. Reset --soft to the base commit (deletes commits, keeps files staged)
    git reset --soft "$merge_base"
    
    echo "Historial reset. All changes are staged."
    # 3. Open commit editor for the unified message
    git commit
}

# FUNCTION: grb() (Git Rebase onto Main)
# Syncs 'main' and then rebases the current branch onto the updated 'main'.
function grb() {
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    if [[ "$current_branch" == "main" || "$current_branch" == "develop" ]]; then
        echo "Error: Cannot rebase the main branch ($current_branch)!"
        return 1
    fi

    echo "Synchronizing main branch..."
    # 1. Pull and sync the main branch
    git checkout main && git pull origin main
    
    echo "Rebasing $current_branch onto main..."
    # 2. Rebase
    git checkout "$current_branch" && git rebase main

    # 3. Force push the rebased branch (use fpush alias for safety)
    echo "Force pushing rebased branch..."
    git push --force-with-lease
}

# FUNCTION: gpr() (Git Pull Request) - Title based on the latest Commit
# Creates an Azure DevOps PR using the message of the most recent commit as the title.
# Requires Azure CLI ('az') and the 'azure-devops' extension.
# Usage: gpr [target_branch - default is main]
function gpr() {
    local source_branch
    source_branch=$(git rev-parse --abbrev-ref HEAD)
    local target_branch=${1:-main}  # Default target is 'main'

    # Capture the subject of the last commit
    local pr_title
    pr_title=$(git log -1 --pretty=%s)

    # Safety check
    if [[ "$source_branch" == "main" || "$source_branch" == "develop" ]]; then
        echo "ERROR: Cannot create a PR from a primary branch ($source_branch)!"
        return 1
    fi
    
    echo "Creating Pull Request for $source_branch towards $target_branch..."
    echo "PR Title: $pr_title"
    
    # Call the Azure CLI
    az repos pr create \
        --title "$pr_title" \
        --description "PR created from $source_branch. Commit message: $pr_title" \
        --source-branch "$source_branch" \
        --target-branch "$target_branch" \
        --auto-complete false \
        --open
    
    # The --open flag will open the PR in your browser.
}
# FUNCTION: gclr (Git Clear Working Directory - SAFE MODE)
# Shows files to be affected and asks for confirmation before clearing the directory and staging area.
function gclr() {
    local modified_and_staged_files
    local untracked_files
    
    # 1. Check for ALL tracked files that are modified (in working directory or staged)
    # This captures the state of all tracked files that are NOT HEAD.
    modified_and_staged_files=$(git status --porcelain | grep -v "^??" | awk '{print $2}')
    
    # 2. Check for untracked files/directories (dry-run)
    untracked_files=$(git clean -dfn)

    # 3. Check if there's anything to clean
    if [ -z "$modified_and_staged_files" ] && [ -z "$untracked_files" ]; then
        echo "‚úÖ Working directory and staging area are already clean."
        return 0
    fi

    echo "=========================================================="
    echo "‚ö†Ô∏è WARNING: TOTAL DIRECTORY CLEANUP IMMINENT"
    echo "This operation will discard ALL uncommitted changes (Staged and Unstaged)."
    echo "=========================================================="
    
    # Show Tracked Modified Files (Staged or Unstaged)
    if [ -n "$modified_and_staged_files" ]; then
        echo ">>> TRACKED MODIFIED FILES (Will be DISCARDED):"
        echo "$modified_and_staged_files"
    fi

    # Show Untracked Files/Directories to be Deleted
    if [ -n "$untracked_files" ]; then
        echo ""
        echo ">>> UNTRACKED FILES AND DIRECTORIES (Will be DELETED):"
        echo "$untracked_files" | sed 's/Would remove //g'
    fi

    echo "=========================================================="
    
    # Ask for confirmation
    read -r -p "Do you want to PROCEED with the full cleanup? (y/N) " response
    
    case "$response" in
        [yY][eE][sS]|[yY]) 
            # 1. UNSTAGE: Move all staged files back to the working directory
            echo "1. Unstaging all files (git restore --staged .)..."
            git restore --staged .
            
            # 2. DISCARD TRACKED: Discard all changes in the working directory
            echo "2. Discarding all tracked changes (git restore .)..."
            git restore .
            
            # 3. CLEAN UNTRACKED: Delete new files and directories
            echo "3. Deleting untracked files and directories (git clean -fd)..."
            git clean -fd
            
            echo "‚úÖ Cleanup complete. Directory and staging area match last commit (HEAD)."
            ;;
        *)
            echo "Operation cancelled. No changes were discarded."
            return 1
            ;;
    esac
}
